#!/usr/bin/env python
#
#   6015  Download IGC tracklogs from Brauniger IQ Basic and Flytec 6015 flight recorders
#   Copyright (C) 2011  Tom Payne <twpayne@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


import datetime
from glob import glob
import logging
from optparse import OptionParser
import os
import os.path
import re
import select
import struct
import sys
from tempfile import NamedTemporaryFile
import tty


DEVICE_GLOBS = {
        'Darwin': ('/dev/cu.usbserial*',),
        'FreeBSD': ('/dev/cuad*',),
        'Linux': ('/dev/ttyUSB*',)}


class Error(RuntimeError):
    pass


class TimeoutError(Error):
    pass


class ReadError(Error):
    pass


class WriteError(Error):
    pass


class UTC(datetime.tzinfo):

    def utcoffset(self, dt):
        return datetime.timedelta(0)

    def tzname(self):
        return "UTC"

    def dst(self, dt):
        return datetime.timedelta(0)


class Flight(object):

    def __init__(self, line):
        fields = re.split(r'\s*;\s*', line)
        self.number = int(fields[0])
        year, month, day = (int(x) for x in fields[1].split('.'))
        hour, minute, second = (int(x) for x in fields[2].split(':'))
        self.datetime = datetime.datetime(year + 2000, month, day, hour, minute, second, tzinfo=utc.UTC())


class SixtyFifteen(object):

    def __init__(self, filename):
        logging.info('opening %r' % filename)
        self.fd = os.open(filename, os.O_RDWR | os.O_NOCTTY | os.O_NONBLOCK)
        tty.setraw(self.fd)
        attr = tty.tcgetattr(self.fd)
        attr[tty.ISPEED] = attr[tty.OSPEED] = tty.B57600
        tty.tcsetattr(self.fd, tty.TCSAFLUSH, attr)
        self.buffer = ''

    def ieach(self, command):
        self.write(command)
        while True:
            line = self.readline()
            if line == 'Done\r\n':
                return
            else:
                yield line

    def readline(self):
        line = ''
        while True:
            index = self.buffer.find('\r\n')
            if index == -1:
                line += self.buffer
                if select.select([self.fd], [], [], 1) == ([], [], []):
                    raise TimeoutError
                self.buffer = os.read(self.fd, 1024)
                logging.debug('read %r' % self.buffer)
                if len(self.buffer) == 0:
                    raise ReadError
            else:
                line += self.buffer[:index + 2]
                self.buffer = self.buffer[index + 2:]
                logging.info('readline %r' % line)
                return line

    def write(self, line):
        logging.info('writing %r' % line)
        if os.write(self.fd, line) != len(line):
            raise WriteError

    def rfa(self, parameter, format):
        for line in self.ieach('RFA_%02x\r\n' % parameter):
            m = re.match(r'\ARFA_%02X_((?:[0-9A-Fa-f]{2})*)\r\n\Z' % parameter, line)
            if m:
                return struct.unpack(format, ''.join(chr(int(x, 16)) for x in re.findall(r'..', m.group(2))))
            if line == 'No Par\r\n':
                return None
            logging.error('unexpected response %r' % line)
        logging.error('no response')

    def flight_book(self):
        serial_number = self.rfa(0x00, '<I')
        logger.info('serial number = %r' % serial_number)
        manufacturer = ('FLY', 'BRA')[self.rfa(0x01, 'B')]
        logger.info('manufacturer = %r' % manufacturer)
        result = [Flight.parse(line) for line in self.ieach('ACT_20_00\r\n')]
        date, index = None, 0
        for flight in result:
            if flight.datetime.date() == date:
		index += 1
            else:
		index = 1
            flight.igc_filename = '%s-%s-%s-%02d.IGC' % (flight.datetime.strftime('%Y-%m-%d'), manufacturer, serial_number, index)
            date = flight.datetime.date()
        return result

    def get_igc_flight(self, flight):
        lines = []
        for line in self.ieach('ACT_21_%02x\r\n' % flight.number):
            lines.append(line)
            if line.startswith('G'):
                break
        return lines


def main(argv):
    parser = OptionParser()
    parser.add_option('-d', '--device', metavar='DEVICE')
    parser.add_option('-v', '--verbose', action='count', dest='level')
    parser.set_defaults(level=0)
    options, args = parser.parse_args(argv[1:])
    if not options.device:
        for device_glob in DEVICE_GLOBS.get(os.uname()[0], ()):
            for device in glob(device_glob):
                if not options.device:
                    options.device = device
    if not options.device:
        logging.error('Could not find device')
        return 1
    logging.basicConfig(level=logging.WARN - 10 * options.level)
    sixty_fifteen = SixtyFifteen(options.device)
    for flight in sixty_fifteen.flight_book():
        if not os.path.exists(flight.igc_filename):
            print 'Downloading %s...' % flight.igc_filename,
            f = NamedTemporaryFile(prefix='6015', delete=False)
            try:
                f.write(''.join(sixty_fifteen.get_igc_flight(flight)))
                f.close()
                os.rename(f.name, flight.igc_filename)
            except:
                os.unlink(f.name)
                raise
            print


if __name__ == '__main__':
    sys.exit(main(sys.argv))
