#!/usr/bin/env python
#
#   flytec-download  Download IGC tracklogs from Brauniger IQ Basic and Flytec 6015 track recorders
#   Copyright (C) 2011  Tom Payne <twpayne@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


import datetime
from glob import glob
import logging
import json
from optparse import OptionParser
import os
import os.path
import re
import sys
import time
from tempfile import NamedTemporaryFile

from flytec import Flytec
from flytec.utc import UTC


class UserError(RuntimeError):

    def __init__(self, message):
        RuntimeError.__init__(self)
        self.message = message


class RangeSet(object):

    def __init__(self, s):
        self.slices = []
        for f in re.split(r'\s*,\s*', s):
            m = re.match(r'\A(\d*)(?:(-)(\d*))?\Z', f)
            if not m:
                raise UserError('invalid range %r' % f)
            start = int(m.group(1)) if m.group(1) else None
            if m.group(2):
                stop = int(m.group(3)) if m.group(3) else None
            else:
                stop = start
            self.slices.append(slice(start, stop))

    def __contains__(self, x):
        for sl in self.slices:
            if sl.start is not None and x < sl.start:
                continue
            if sl.stop is not None and sl.stop < x:
                continue
            return True
        return False


def main(argv):
    basename = os.path.basename(argv[0])
    parser = OptionParser()
    parser.add_option('-d', '--device', metavar='DEVICE', help='set device filename')
    parser.add_option('-o', '--overwrite', action='store_true', help='re-download already downloaded tracklogs')
    parser.add_option('-v', '--verbose', action='count', dest='level', help='show debugging information')
    parser.set_defaults(level=0)
    options, args = parser.parse_args(argv[1:])
    logging.basicConfig(level=logging.WARN - 10 * options.level)
    try:
        flytec = Flytec(options.device)
        if flytec is None:
            raise UserError('no flight recorder detected')
        if len(args) == 0 or args[0] == 'do' or args[0] == 'download':
            sys.stdout.write('%s: found %s %s #%d (%s) on %s\n' % (basename, flytec.manufacturer_name, flytec.model, flytec.serial_number, flytec.pilot_name, flytec.io.filename))
            count = 0
            range_sets = list(RangeSet(arg) for arg in args[1:])
            for i, track in enumerate(flytec.tracks):
                if range_sets and not any(i + 1 in rs for rs in range_sets):
                    continue
                if options.overwrite or not os.path.exists(track.igc_filename):
                    sys.stdout.write('%s: downloading %s    0%%  --:--' % (basename, track.igc_filename))
                    output = NamedTemporaryFile(prefix='flytec', delete=False)
                    try:
                        here = track.datetime
                        percentage, remaining = 0, None
                        start = time.time()
                        for line in track.igc():
                            output.write(line)
                            m = re.match(r'\AB(\d\d)(\d\d)(\d\d)', line)
                            if m:
                                hour, minute, second = (int(g) for g in m.groups())
                                here = here.replace(hour=hour, minute=minute, second=second)
                            m = re.match(r'\AHFDTE(\d\d)(\d\d)(\d\d)', line)
                            if m:
                                day, month, year = (int(g) for g in m.groups())
                                here = datetime.datetime(2000 + year, month, day, 0, 0, 0, tzinfo=UTC())
                            prev_percentage = percentage
                            percentage = int(100 * (here - track.datetime).seconds / track.duration.seconds)
                            percentage = max(min(percentage, 100), 0)
                            prev_remaining = remaining
                            now = time.time()
                            if here == track.datetime or now - start < 2:
                                remaining = None
                            else:
                                remaining = (now - start) * max((track.datetime + track.duration - here).seconds, 0) / (here - track.datetime).seconds
                                remaining = max(remaining, 0)
                                if prev_remaining is not None:
                                    remaining = min(remaining, prev_remaining)
                            if percentage != prev_percentage or remaining != prev_remaining:
                                sys.stdout.write('\b\b\b\b\b\b\b\b\b\b\b%3d%%  ' % percentage)
                                if remaining is None:
                                    sys.stdout.write('--:--')
                                else:
                                    sys.stdout.write('%02d:%02d' % divmod(remaining, 60))
                                sys.stdout.flush()
                        output.close()
                        os.rename(output.name, track.igc_filename)
                        duration = time.time() - start
                        sys.stdout.write('\b\b\b\b\b\b\b\b\b\b\b100%%  %02d:%02d\n' % divmod(duration, 60))
                        count += 1
                    except:
                        os.unlink(output.name)
                        raise
                else:
                    sys.stdout.write('%s: skipping %s\n' % (basename, track.igc_filename))
            sys.stdout.write('%s: %d tracklogs downloaded\n' % (basename, count))
        elif args[0] == 'id':
            if len(args) > 1:
                raise UserError('extra arguments on command line %r' % args[1:])
            sys.stdout.write(json.dumps(flytec.to_json(), indent=4, sort_keys=True))
            sys.stdout.write('\n')
        elif args[0] == 'li' or args[0] == 'list':
            if len(args) > 1:
                raise UserError('extra arguments on command line %r' % args[1:])
            sys.stdout.write(json.dumps({'tracks': [track.to_json() for track in flytec.tracks]}, indent=4, sort_keys=True))
            sys.stdout.write('\n')
        elif args[0] == 'ch' or args[0] == 'check':
            flytec.check()
        else:
            raise UserError('invalid command %r' % args)
    except UserError, e:
        sys.stdout.write('%s: %s\n' % (basename, e.message))
        return 1


if __name__ == '__main__':
    sys.exit(main(sys.argv))
