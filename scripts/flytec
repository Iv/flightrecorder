#!/usr/bin/env python
#
#   flytec-download  Download IGC tracklogs from Brauniger IQ Basic and Flytec 6015 track recorders
#   Copyright (C) 2011  Tom Payne <twpayne@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


import datetime
from glob import glob
import logging
import json
from optparse import OptionParser
import os
import os.path
import re
import sys
import time
from tempfile import NamedTemporaryFile
import zipfile

from flytec import Flytec
from flytec.utc import UTC
import flytec.waypoint as waypoint


class UserError(RuntimeError):

    def __init__(self, message):
        RuntimeError.__init__(self)
        self.message = message


class RangeSet(object):

    def __init__(self, s):
        self.slices = []
        for f in re.split(r'\s*,\s*', s):
            m = re.match(r'\A(\d*)(?:(-)(\d*))?\Z', f)
            if not m:
                raise UserError('invalid range %r' % f)
            start = int(m.group(1)) if m.group(1) else None
            if m.group(2):
                stop = int(m.group(3)) if m.group(3) else None
            else:
                stop = start
            self.slices.append(slice(start, stop))

    def __contains__(self, x):
        for sl in self.slices:
            if sl.start is not None and x < sl.start:
                continue
            if sl.stop is not None and sl.stop < x:
                continue
            return True
        return False


def abbreviator(items):
    result = {}
    for item in items:
        for key in (item[:i] for i in xrange(1, len(item) + 1)):
            if key in result:
                result[key] = None
            else:
                result[key] = item
    return result


def main(argv):
    basename = os.path.basename(argv[0])
    parser = OptionParser()
    parser.add_option('-d', '--device', metavar='DEVICE', help='set device filename')
    parser.add_option('-f', '--format', metavar='FORMAT', help='set output format')
    parser.add_option('-o', '--output', metavar='FILENAME', help='set output filename')
    parser.add_option('--overwrite', action='store_true', help='re-download already downloaded tracklogs')
    parser.add_option('-v', '--verbose', action='count', dest='level', help='show debugging information')
    parser.set_defaults(level=0)
    options, args = parser.parse_args(argv[1:])
    logging.basicConfig(level=logging.WARN - 10 * options.level)
    try:
        if args:
            command = abbreviator('check download dump id list waypoints zip'.split()).get(args[0])
            if command is None:
                raise UserError('unknown or ambiguous command %r' % args[0])
        else:
            command = 'download'
        flytec = Flytec(options.device)
        if flytec is None:
            raise UserError('no flight recorder detected')
        if command in ('download', 'zip'):
            sys.stdout.write('%s: found %s %s #%d (%s) on %s\n' % (basename, flytec.manufacturer_name, flytec.model, flytec.serial_number, flytec.pilot_name, flytec.io.filename))
            zipfile = zipfile.ZipFile(options.output or 'tracklogs.zip', 'w') if command == 'zip' else None
            count = 0
            range_sets = list(RangeSet(arg) for arg in args[1:])
            for i, track in enumerate(flytec.tracks):
                if range_sets and not any(i + 1 in rs for rs in range_sets):
                    continue
                if zipfile is None and os.path.exists(track.igc_filename) and not options.overwrite:
                    sys.stdout.write('%s: skipping %s\n' % (basename, track.igc_filename))
                    continue
                sys.stdout.write('%s: downloading %s    0%%  --:--' % (basename, track.igc_filename))
                lines = []
                here = track.datetime
                percentage, remaining = 0, None
                start = time.time()
                for line in track.igc:
                    lines.append(line)
                    m = re.match(r'\AB(\d\d)(\d\d)(\d\d)', line)
                    if m:
                        hour, minute, second = (int(g) for g in m.groups())
                        here = here.replace(hour=hour, minute=minute, second=second)
                    m = re.match(r'\AHFDTE(\d\d)(\d\d)(\d\d)', line)
                    if m:
                        day, month, year = (int(g) for g in m.groups())
                        here = datetime.datetime(2000 + year, month, day, 0, 0, 0, tzinfo=UTC())
                    prev_percentage = percentage
                    percentage = int(100 * (here - track.datetime).seconds / track.duration.seconds)
                    percentage = max(min(percentage, 100), 0)
                    prev_remaining = remaining
                    now = time.time()
                    if here == track.datetime or now - start < 2:
                        remaining = None
                    else:
                        remaining = (now - start) * max((track.datetime + track.duration - here).seconds, 0) / (here - track.datetime).seconds
                        remaining = max(remaining, 0)
                        if prev_remaining is not None:
                            remaining = min(remaining, prev_remaining)
                    if percentage != prev_percentage or remaining != prev_remaining:
                        sys.stdout.write('\b\b\b\b\b\b\b\b\b\b\b%3d%%  ' % percentage)
                        if remaining is None:
                            sys.stdout.write('--:--')
                        else:
                            sys.stdout.write('%02d:%02d' % divmod(remaining, 60))
                        sys.stdout.flush()
                if zipfile:
                    zipinfo = zipfile.ZipInfo(track.igc_filename)
                    zipinfo.date_time = (track.datetime + track.duration).timetuple()[:6]
                    zipinfo.external_attr = 0644 << 16
                    zipfile.writestr(zipinfo, ''.join(track.igc))
                else:
                    output = NamedTemporaryFile(prefix='flytec', delete=False)
                    for line in lines:
                        output.write(line)
                    output.close()
                    os.rename(output.name, track.igc_filename)
                duration = time.time() - start
                sys.stdout.write('\b\b\b\b\b\b\b\b\b\b\b100%%  %02d:%02d\n' % divmod(duration, 60))
                count += 1
            if zipfile:
                zipfile.close()
            sys.stdout.write('%s: %d tracklogs downloaded\n' % (basename, count))
        elif command == 'dump':
            json.dump(flytec.dump(), sys.stdout, indent=4, sort_keys=True)
        elif command == 'id':
            if len(args) > 1:
                raise UserError('extra arguments on command line %r' % args[1:])
            json.dump(flytec.to_json(), sys.stdout, indent=4, sort_keys=True)
            sys.stdout.write('\n')
        elif command == 'list':
            if len(args) > 1:
                raise UserError('extra arguments on command line %r' % args[1:])
            json.dump(dict(tracks=[track.to_json() for track in flytec.tracks]), sys.stdout, indent=4, sort_keys=True)
            sys.stdout.write('\n')
        elif command == 'waypoints':
            if len(args) == 1:
                subcommand = 'download'
            elif len(args) == 2:
                subcommand = abbreviator('delete-all download'.split()).get(args[1])
                if subcommand is None:
                    raise UserError('unknown or ambiguous waypoints command %r' % args[1])
            else:
                raise UserError('extra arguments on command line %r' % args[2:])
            if subcommand == 'delete-all':
                del flytec.waypoints
            elif subcommand == 'download':
                if options.output:
                    output = open(options.output, 'w')
                else:
                    output = sys.stdout
                if options.format:
                    format = abbreviator('compegps formatgeo oziexplorer seeyou'.split()).get(options.format)
                    if format is None:
                        raise UserError('unknown waypoint format %r' % options.format)
                else:
                    format = 'oziexplorer'
                waypoint.dump(flytec.waypoints, output, format=format)
    except UserError, e:
        sys.stdout.write('%s: %s\n' % (basename, e.message))
        return 1


if __name__ == '__main__':
    sys.exit(main(sys.argv))
