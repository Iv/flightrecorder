#!/usr/bin/env python
#
#   flytec-download  Download IGC tracklogs from Brauniger IQ Basic and Flytec 6015 track recorders
#   Copyright (C) 2011  Tom Payne <twpayne@gmail.com>
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.


from glob import glob
import logging
import json
from optparse import OptionParser
import os
import os.path
import re
import sys
from tempfile import NamedTemporaryFile

from flytec.errors import TimeoutError
from flytec.serialio import SerialIO
from flytec.sixty15 import MockSixty15IO, Sixty15
from flytec.fifty20 import Fifty20


DEVICE_GLOBS = {
        'Darwin': ('/dev/cu.PL2303*', '/dev/cu.usbserial*',),
        'FreeBSD': ('/dev/cuad*',),
        'Linux': ('/dev/ttyUSB*',)}


class UserError(RuntimeError):

    def __init__(self, message):
        RuntimeError.__init__(self)
        self.message = message


class RangeSet(object):

    def __init__(self, s):
        self.slices = []
        for f in re.split(r'\s*,\s*', s):
            m = re.match(r'\A(\d+)(?:-(\d+))?\Z', f)
            if not m:
                raise UserError('invalid range %r' % f)
            start = int(m.group(1))
            stop = int(m.group(2)) + 1 if m.group(2) else start + 1
            self.slices.append(slice(start, stop))

    def __contains__(self, x):
        return any(sl.start <= x < sl.stop for sl in self.slices)


def main(argv):
    parser = OptionParser()
    parser.add_option('-d', '--device', metavar='DEVICE', help='set device filename')
    parser.add_option('-o', '--overwrite', action='store_true', help='re-download already downloaded tracklogs')
    parser.add_option('-v', '--verbose', action='count', dest='level', help='show debugging information')
    parser.set_defaults(level=0)
    options, args = parser.parse_args(argv[1:])
    logging.basicConfig(level=logging.WARN - 10 * options.level)
    if not args:
        args = ('download',)
    if options.device:
        devices = (options.device,)
    else:
        devices = list(filename for device_glob in DEVICE_GLOBS.get(os.uname()[0], ()) for filename in sorted(glob(device_glob)))
    if not devices:
        logging.error('Could not find serial port device')
        return 1
    flight_recorder = None
    for device in devices:
        if device == 'mock-6015':
            flight_recorder = Sixty15(MockSixty15IO())
        else:
            for klass in Sixty15, Fifty20:
                try:
                    flight_recorder = klass(SerialIO(device))
                    break
                except IOError:
                    pass
                except TimeoutError:
                    pass
            else:
                continue
        break
    if flight_recorder is None:
        logging.error('No Flytec or Brauniger flight recorders detected')
        return 1
    try:
        if args[0] == 'do' or args[0] == 'download':
            range_sets = [RangeSet(arg) for arg in args[1:]]
            for i, track in enumerate(flight_recorder.tracks()):
                if range_sets and not any(i + 1 in rs for rs in range_sets):
                    continue
                if options.overwrite or not os.path.exists(track.igc_filename):
                    print 'Downloading %s...' % track.igc_filename,
                    f = NamedTemporaryFile(prefix='flytec', delete=False)
                    try:
                        f.write(''.join(track.igc()))
                        f.close()
                        os.rename(f.name, track.igc_filename)
                    except:
                        os.unlink(f.name)
                        raise
                    print
        elif args[0] == 'id':
            if len(args) > 1:
                raise UserError('extra arguments on command line %r' % args[1:])
            print json.dumps(flight_recorder.to_json(), indent=4, sort_keys=True)
        elif args[0] == 'li' or args[0] == 'list':
            if len(args) > 1:
                raise UserError('extra arguments on command line %r' % args[1:])
            print json.dumps({'tracks': [track.to_json() for track in flight_recorder.tracks()]}, indent=4, sort_keys=True)
        else:
            raise UserError('invalid command %r' % args)
    except UserError, e:
        print '%s: %s' % (os.path.basename(argv[0]), e.message)
        return 1


if __name__ == '__main__':
    sys.exit(main(sys.argv))
